@page
@model portaBLe.Pages.PlayersPPGraphModel
@{
    ViewData["Title"] = "Players Triangle Graph";
}

<h2>@ViewData["Title"]</h2>

<div class="container-fluid">
    <div class="row mb-3">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Filters</h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-3">
                            <div class="form-group">
                                <label for="maxPlayerRank">Max Player Rank</label>
                                <input id="maxPlayerRank" type="number" class="form-control" value="@Model.MaxPlayerRank" placeholder="0 = unfiltered" />
                                <small class="form-text text-muted">0 = unfiltered</small>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="form-group">
                                <label for="minRankedPlayCount">Min Ranked Play Count</label>
                                <input id="minRankedPlayCount" type="number" class="form-control" value="@Model.MinRankedPlayCount" />
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="form-group">
                                <label for="playerId">Player ID (optional)</label>
                                <input id="playerId" type="text" class="form-control" value="@Model.PlayerId" placeholder="Enter player ID" />
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="form-group">
                                <label for="colorSelect">Color by:</label>
                                <select id="colorSelect" class="form-control">
                                    <option value="AccPP">AccPP</option>
                                    <option value="TechPP">TechPP</option>
                                    <option value="PassPP">PassPP</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-12">
                            <button id="applyFilters" class="btn btn-primary">Apply Filters</button>
                            <div id="spinner" class="spinner-border spinner-border-sm ml-2" role="status" style="display:none;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">3D Player Distribution</h5>
                    <small class="text-muted">Interactive 3D scatter plot of AccPP, TechPP, and PassPP</small>
                </div>
                <div class="card-body">
                    <div id="noDataMessage" style="display:none; text-align:center; padding:50px; color:gray; font-size:16px;">
                        Click "Apply Filters" to load data
                    </div>
                    <div id="myPlot" style="width:100%;height:600px;"></div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
    <script type="text/javascript">
        let players = @Html.Raw(Model.TriangleJsonData);
        let isRendering = false;

        function renderPlot(playersData, colorVariable = 'AccPP') {
            // Prevent recursive calls
            if (isRendering) {
                console.warn('renderPlot already in progress, skipping recursive call');
                return;
            }
            
            isRendering = true;
            
            try {
                const noDataMsg = document.getElementById('noDataMessage');
                const plotDiv = document.getElementById('myPlot');
                
                if (!playersData || playersData.length === 0) {
                    // Show no data message and hide plot
                    if (noDataMsg) noDataMsg.style.display = 'block';
                    if (plotDiv) plotDiv.style.display = 'none';
                    return;
                }
                
                // Hide no data message and show plot
                if (noDataMsg) noDataMsg.style.display = 'none';
                if (plotDiv) plotDiv.style.display = 'block';

                // Map the selected variable to marker color
                let colorValues, colorTitle, colorscale;
                if (colorVariable === 'AccPP') {
                    colorValues = playersData.map(p => Number(p.accPP));
                    colorTitle = 'AccPP';
                    colorscale = 'Viridis';
                } else if (colorVariable === 'TechPP') {
                    colorValues = playersData.map(p => Number(p.techPP));
                    colorTitle = 'TechPP';
                    colorscale = 'Cividis';
                } else if (colorVariable === 'PassPP') {
                    colorValues = playersData.map(p => Number(p.passPP));
                    colorTitle = 'PassPP';
                    colorscale = 'Plasma';
                }

                const maxColor = colorValues.length > 0 ? Math.max(...colorValues) : 1;

                const trace = {
                    type: 'scatter3d',
                    mode: 'markers',
                    x: playersData.map(p => Number(p.accPP)),
                    y: playersData.map(p => Number(p.techPP)),
                    z: playersData.map(p => Number(p.passPP)),
                    text: playersData.map(p => (p.player || '') + ' (' + (p.id || '') + ')'),
                    customdata: playersData.map(p => [p.accPP, p.techPP, p.passPP]),
                    hovertemplate: 'Player: %{text}<br>AccPP: %{customdata[0]:.2f}<br>TechPP: %{customdata[1]:.2f}<br>PassPP: %{customdata[2]:.2f}<extra></extra>',
                    marker: { 
                        size: 6,
                        color: colorValues,
                        colorscale: colorscale,
                        cmin: 0,
                        cmax: maxColor,
                        colorbar: { title: colorTitle },
                        opacity: 0.8 }
                };

                const layout = {
                    scene: {
                        xaxis: { title: 'AccPP' },
                        yaxis: { title: 'TechPP' },
                        zaxis: { title: 'PassPP' }
                    },
                    margin: { t: 10, b: 10, l: 10, r: 10 }
                };

                const config = { staticPlot: false, displayModeBar: true, responsive: true };

                Plotly.react('myPlot', [trace], layout, config);
            } finally {
                isRendering = false;
            }
        }

        // Load saved color selection from URL or localStorage
        function loadColorSelection() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlColor = urlParams.get('colorBy');
            const savedColor = localStorage.getItem('playersPPGraph_colorBy');
            const colorSelect = document.getElementById('colorSelect');
            
            const colorToUse = urlColor || savedColor || 'AccPP';
            if (colorSelect && colorSelect.value !== colorToUse) {
                colorSelect.value = colorToUse;
            }
            return colorToUse;
        }

        // Save color selection to localStorage and URL
        function saveColorSelection(colorBy) {
            localStorage.setItem('playersPPGraph_colorBy', colorBy);
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('colorBy') !== colorBy) {
                urlParams.set('colorBy', colorBy);
                const newUrl = window.location.pathname + '?' + urlParams.toString();
                window.history.replaceState({}, '', newUrl);
            }
        }

        // Initial render with saved color selection
        const initialColor = loadColorSelection();
        renderPlot(players || [], initialColor);

        // Dropdown event listener
        const colorSelectElement = document.getElementById('colorSelect');
        if (colorSelectElement) {
            colorSelectElement.addEventListener('change', function() {
                const selected = this.value;
                saveColorSelection(selected);
                renderPlot(players, selected);
            });
        }

        function showSpinner(show) {
            const spinner = document.getElementById('spinner');
            if (spinner) spinner.style.display = show ? 'inline-block' : 'none';
        }

        async function fetchFiltered() {
            const maxPlayerRank = parseInt(document.getElementById('maxPlayerRank')?.value) || 0;
            const minRankedPlayCount = parseInt(document.getElementById('minRankedPlayCount')?.value) || 0;
            const playerId = (document.getElementById('playerId')?.value || '').trim();
            const colorBy = document.getElementById('colorSelect')?.value || 'AccPP';

            // Update the browser URL with filter parameters so they persist when switching databases
            const pageUrl = new URL(window.location.href);
            pageUrl.searchParams.set('maxPlayerRank', maxPlayerRank);
            pageUrl.searchParams.set('minRankedPlayCount', minRankedPlayCount);
            pageUrl.searchParams.set('playerId', playerId);
            pageUrl.searchParams.set('colorBy', colorBy);
            window.history.replaceState({}, '', pageUrl);

            const url = new URL(window.location.href);
            url.pathname = url.pathname.replace(/\/$/, '');
            const dbParam = url.searchParams.get('db');
            url.search = `?handler=Data&maxPlayerRank=${encodeURIComponent(maxPlayerRank)}&minRankedPlayCount=${encodeURIComponent(minRankedPlayCount)}&playerId=${encodeURIComponent(playerId)}`;
            if (dbParam) url.searchParams.set('db', dbParam);

            console.log('Fetching from URL:', url.toString());
            showSpinner(true);
            try {
                const resp = await fetch(url.toString(), { headers: { 'Accept': 'application/json' } });
                if (!resp.ok) {
                    console.error('Failed to fetch filtered data. Status:', resp.status);
                    alert('Failed to load player data. Please check the console for details.');
                    return;
                }
                const json = await resp.json();
                console.log('Received data:', json);
                players = json;
                renderPlot(players, colorBy);
            } catch (error) {
                console.error('Error fetching filtered data:', error);
                alert('An error occurred while loading player data: ' + error.message);
            } finally {
                showSpinner(false);
            }
        }

        document.getElementById('applyFilters')?.addEventListener('click', fetchFiltered);

        // Auto-load data on page load if filter parameters are present in URL
        function shouldAutoLoad() {
            const urlParams = new URLSearchParams(window.location.search);
            // Check if any filter parameter is set (excluding just 'db')
            const filterParams = ['maxPlayerRank', 'minRankedPlayCount', 'playerId'];
            return filterParams.some(param => urlParams.has(param) && urlParams.get(param) !== '' && urlParams.get(param) !== '0');
        }

        // Auto-load on page load if filters are present
        if (shouldAutoLoad()) {
            fetchFiltered();
        }
    </script>
}