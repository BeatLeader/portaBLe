@page
@model portaBLe.Pages.WeightedScoresGraphModel
@{
    ViewData["Title"] = "Weighted Scores Graph";
}

<h2>Weighted Scores Graph</h2>

<div class="graph-controls">
    <div class="control">
        <label for="minWeight">Min Score Weight (%)</label>
        <input id="minWeight" type="number" step="0.1" min="0" max="100" value="@Model.MinWeightPercent" />
    </div>

    <div class="control">
        <label>From Date (Y / M / D)</label>
        <div style="display:flex;gap:6px;">
            <input id="minYear" type="number" placeholder="Year" value="@Model.MinYear" style="width:100px;" />
            <input id="minMonth" type="number" placeholder="Month" value="@Model.MinMonth" style="width:70px;" />
            <input id="minDay" type="number" placeholder="Day" value="@Model.MinDay" style="width:70px;" />
        </div>
    </div>

    <div class="control">
        <label for="maxPlayerRank">Max Player Rank (0 = unfiltered)</label>
        <input id="maxPlayerRank" type="number" value="@Model.MaxPlayerRank" />
    </div>

    <div class="control">
        <label for="minRankedPlayCount">Min Ranked Play Count</label>
        <input id="minRankedPlayCount" type="number" value="@Model.MinRankedPlayCount" />
    </div>

    <div class="control">
        <label for="playerId">Player ID (optional)</label>
        <input id="playerId" type="text" value="@Model.PlayerId" />
    </div>

    <div class="control">
        <label for="ySelect">Select Y-axis</label>
        <select id="ySelect">
            <option value="pp">Weighted PP</option>
            <option value="acc">Score Accuracy</option>
            <option value="accPP">Weighted Acc PP</option>
            <option value="passPP">Weighted Pass PP</option>
            <option value="techPP">Weighted Tech PP</option>
        </select>
    </div>

    <div class="control">
        <label for="rollingWindow">Rolling window smoothing (points)</label>
        <input id="rollingWindow" type="number" min="1" step="1" value="50" />
    </div>

    <div class="controls-bottom">
        <button id="applyFilters" class="apply-button">Apply</button>
        <div id="spinner" class="spinner-container" style="display:none;">
            <div class="spinner" aria-hidden="true"></div>
            <span style="margin-left:8px;">Loading...</span>
        </div>
        <div class="magic-box">
            <span id="magicLabel">Rolling average value (0 = perfectly linear):</span>
            <strong id="magicValue" style="margin-left:8px;">-</strong>
        </div>
    </div>
</div>

<div id="myPlot" style="width:100%;height:500px;margin-top:10px;"></div>

@section Scripts {
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>
    <script>
        let data = @Html.Raw(Model.WeightedJsonData);

        function getYLabel(yField) {
            switch (yField) {
                case 'pp': return 'Weighted PP';
                case 'acc': return 'Score Accuracy';
                case 'accPP': return 'Weighted Acc PP';
                case 'passPP': return 'Weighted Pass PP';
                case 'techPP': return 'Weighted Tech PP';
                default: return yField;
            }
        }

        function computeRollingAverage(points, yField, windowSize, maxPoints = 200) {
            if (!points || points.length === 0) return { xs: [], ys: [] };
            const pts = points.slice().sort((a, b) => a.x - b.x);
            const n = pts.length;
            const half = Math.floor(windowSize / 2);
            const xsFull = new Array(n);
            const ysFull = new Array(n);
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - half);
                const end = Math.min(n - 1, i + half);
                let sum = 0;
                let count = 0;
                for (let j = start; j <= end; j++) {
                    const v = pts[j][yField];
                    if (v != null && !isNaN(v)) { sum += v; count++; }
                }
                xsFull[i] = pts[i].x;
                ysFull[i] = count > 0 ? sum / count : null;
            }

            // Downsample to at most maxPoints to get a smoother line
            if (n <= maxPoints) return { xs: xsFull, ys: ysFull };
            const step = Math.ceil(n / maxPoints);
            const xs = [];
            const ys = [];
            for (let i = 0; i < n; i += step) {
                xs.push(xsFull[i]);
                ys.push(ysFull[i]);
            }
            // ensure last point included
            if (xs[xs.length - 1] !== xsFull[n - 1]) {
                xs.push(xsFull[n - 1]); ys.push(ysFull[n - 1]);
            }
            return { xs, ys };
        }

        function linearRegression(xs, ys) {
            const n = xs.length;
            let sx = 0, sy = 0, sxx = 0, sxy = 0;
            let valid = 0;
            for (let i = 0; i < n; i++) {
                const x = xs[i], y = ys[i];
                if (y == null || isNaN(y)) continue;
                sx += x; sy += y; sxx += x * x; sxy += x * y; valid++;
            }
            if (valid === 0) return { m: 0, b: 0 };
            const denom = valid * sxx - sx * sx;
            const m = denom === 0 ? 0 : (valid * sxy - sx * sy) / denom;
            const b = (sy - m * sx) / valid;
            return { m, b };
        }

        function computeMagicValue(xs, ys) {
            // RMSE normalized by y-range; 0 = perfectly linear
            const n = xs.length;
            let maxY = -Infinity, minY = Infinity;
            for (let i = 0; i < n; i++) {
                const y = ys[i]; if (y == null || isNaN(y)) continue; if (y > maxY) maxY = y; if (y < minY) minY = y;
            }
            if (!isFinite(maxY) || !isFinite(minY) || maxY === minY) return 0;
            const lr = linearRegression(xs, ys);
            let sumSq = 0, count = 0;
            for (let i = 0; i < n; i++) {
                const x = xs[i], y = ys[i]; if (y == null || isNaN(y)) continue;
                const pred = lr.m * x + lr.b;
                const diff = y - pred;
                sumSq += diff * diff; count++;
            }
            if (count === 0) return 0;
            const rmse = Math.sqrt(sumSq / count);
            const magic = rmse / (maxY - minY);
            return magic;
        }

        function renderPlot(points, yField, windowSize) {
            const tracePoints = {
                x: points.map(p => p.x),
                y: points.map(p => p[yField]),
                mode: 'markers',
                type: 'scattergl',
                marker: { size: 4, color: 'blue', opacity: 0.2 },
                name: 'Points'
            };

            const ra = computeRollingAverage(points, yField, windowSize);
            const traceAvg = {
                x: ra.xs,
                y: ra.ys,
                mode: 'lines',
                type: 'scattergl',
                line: { color: 'red', width: 2 },
                name: `Rolling Avg (${windowSize})`
            };

            const layout = {
                title: 'Weighted Scores Scatter Plot',
                xaxis: { title: 'Stars' },
                yaxis: { title: getYLabel(yField) },
                hovermode: 'closest',
                margin: { t: 50, b: 50, l: 50, r: 50 }
            };
            Plotly.react('myPlot', [tracePoints, traceAvg], layout);

            // compute and display magic value
            const magic = computeMagicValue(ra.xs, ra.ys);
            const label = `Rolling average for ${getYLabel(yField)} (0 = perfectly linear):`;
            document.getElementById('magicLabel').textContent = label;
            document.getElementById('magicValue').textContent = magic.toFixed(4);
        }

        // initial render: default window
        const defaultWindow = parseInt(document.getElementById('rollingWindow').value || '50');
        renderPlot(data, 'pp', defaultWindow);

        document.getElementById('ySelect').addEventListener('change', function () {
            const y = this.value;
            const w = parseInt(document.getElementById('rollingWindow').value || '50');
            renderPlot(data, y, w);
        });

        document.getElementById('rollingWindow').addEventListener('change', function () {
            const y = document.getElementById('ySelect').value;
            const w = parseInt(this.value || '50');
            renderPlot(data, y, w);
        });

        function showSpinner(show) {
            document.getElementById('spinner').style.display = show ? 'flex' : 'none';
        }

        async function fetchFiltered() {
            const minWeight = parseFloat(document.getElementById('minWeight').value) || 0;
            const minYear = parseInt(document.getElementById('minYear').value) || 0;
            const minMonth = parseInt(document.getElementById('minMonth').value) || 0;
            const minDay = parseInt(document.getElementById('minDay').value) || 0;
            const maxPlayerRank = parseInt(document.getElementById('maxPlayerRank').value) || 0;
            const minRankedPlayCount = parseInt(document.getElementById('minRankedPlayCount').value) || 0;
            const playerId = (document.getElementById('playerId').value || '').trim();
            const y = document.getElementById('ySelect').value;
            const windowSize = parseInt(document.getElementById('rollingWindow').value) || 50;

            const url = new URL(window.location.href);
            url.pathname = url.pathname.replace(/\/$/, '');
            url.search = `?handler=Data&minWeightPercent=${encodeURIComponent(minWeight)}&minYear=${encodeURIComponent(minYear)}&minMonth=${encodeURIComponent(minMonth)}&minDay=${encodeURIComponent(minDay)}&maxPlayerRank=${encodeURIComponent(maxPlayerRank)}&minRankedPlayCount=${encodeURIComponent(minRankedPlayCount)}&playerId=${encodeURIComponent(playerId)}`;

            showSpinner(true);
            try {
                const resp = await fetch(url.toString(), { headers: { 'Accept': 'application/json' } });
                if (!resp.ok) {
                    console.error('Failed to fetch filtered data');
                    return;
                }
                const json = await resp.json();
                data = json;
                renderPlot(data, y, windowSize);
            } finally {
                showSpinner(false);
            }
        }

        document.getElementById('applyFilters').addEventListener('click', function () {
            fetchFiltered();
        });
    </script>
    }
}